# udacity-implement-route-planner
A* search to implement a "Google-maps" style route planning algorithm. This project is part of the Udacity' s Introduction to Self-Driving Car Nanodegree program. 

# Description of Files
You will only need to update the "project_notebook.ipynb" file, which is a jupyter notebook, to get through the project. "helper.py" contains map definitions. "test.py" contains a testing scenario and checks if your allgorithm can find the most optimum path for a map of 40 points. Make sure to understand class PathPlanner() methods, especially run_search. I have included several print function to understand how this code works. These print functions are commented, you can uncomment them to work.

# Workflow of the algorithm - Initialization
The constructor (__init__) in class PathPlanner initializes the main parameters. self.map is your 40-points map, self.start is the starting node, self.goal is the target goal. For the test case in "test.py", self.start is 5, self.goal is 34 (they are both integers). For the initial step, self.start node is added into self.openSet via create_openSet method. As the name suggests, self.openSet is a set type data structure. self.gScore includes the g score of all nodes, in a dictionary format. After __init__ executes, the g score of the start node is set to zero, whereas all other nodes are set to 'inf'. You need to write the necessary code for this in create_gScore method. We also need to set f scores for the nodes in the self.openSet. For the initial step, this is done by create_fScore method. You need to set the initial f value of the start node (which is 5) via distance method. This method calculates the hypotenuse distance between two nodes by using dx and dy. You need to calculate dx and dy yourself by using self.map.intersections. This intersection property of the map object gives the x and y coordinates of nodes in a dictionary format. The "Key" is the node number, and the "Value" is a list containing x&y coordinates.

# Workflow of the algorithm - Main (run_search)
run_search method assigns the start node (defined in the previous sections) as current node. Then it relocates it from self.openSet to self.closeSet. get_neighbors method is utilized to find the neighbor nodes of the current node (also known as the frontier). You need to use the roads property of the map object here. Just to check, the neighbors of node:5 (current node) are 32,16,14. These neighbor nodes are added to self.openSet one by one, with the for loop: "for neighbor in self.get_neighbors(current):", if they are not already in the closedSet. The if statement of: "if self.get_tentative_gScore(current, neighbor) >= self.get_gScore(neighbor):" decides if this is a better path or not. Tentative gScore is the gScore of the current node added to the distance of the current node to the neighbor node. If the condition is True, self.record_best_path_to() is executed for this node (in this case node:32). If the condition is False, the algorithm continues to the next neighbor node (which is node:16). For our case the condition is True. What "self.record_best_path_to()" should do is; 1) Update self.comeFrom as {32:5}, 2) Update self.gScore for node:32 (check if it is = 0.2452), 3) Update self.fScore for node:32 (check if it is = 0.91174). After this, the next neighbors of current node (nodes:16 and 14) goes through the same steps. Node:16 is chosen since it has the lowest fScore in the self.openSet. Then the current node is updated from 5 to 16, and the same procedures are applied. The resultant path should be: 5-16-37-12-34.

I have also put a table for a basic visualization of the A* search algorithm. 
